# -*- coding: utf-8 -*-
"""Car Price Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bV7FRd2wBA5JuuOeu7x3-tZCc-lIlLD2
"""

!pip install streamlit pyngrok joblib

from google.colab import files
uploaded = files.upload()

import pandas as pd
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
import joblib

# Load dataset
df = pd.read_csv("CAR DETAILS FROM CAR DEKHO.csv")
df.drop_duplicates(inplace=True)
df.reset_index(drop=True, inplace=True)

# Encode categorical features
le = LabelEncoder()
df['fuel'] = le.fit_transform(df['fuel'])
df['seller_type'] = le.fit_transform(df['seller_type'])
df['transmission'] = le.fit_transform(df['transmission'])
df['owner'] = le.fit_transform(df['owner'])

df.drop('name', axis=1, inplace=True)

X = df.drop('selling_price', axis=1)
y = df['selling_price']

# Train model
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X, y)

# Save model
joblib.dump(model, 'random_forest_model.pkl')

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import joblib
# import seaborn as sns
# import matplotlib.pyplot as plt
# 
# # Load model
# model = joblib.load('random_forest_model.pkl')
# 
# st.title("ğŸš— Car Price Predictor using Random Forest")
# 
# # Dropdown for year selection
# year = st.selectbox("Year of Purchase", ["Select Year"] + list(range(1990, 2025)))
# if year == "Select Year":
#     st.warning("Please select Year of Purchase")
# 
# # Dropdown for km driven
# km_options = ["Select KM Driven", "10000", "20000", "30000", "40000", "50000", "60000", "70000", "80000", "90000", "100000+"]
# km_driven = st.selectbox("Kilometers Driven", km_options)
# if km_driven == "Select KM Driven":
#     st.warning("Please select KM Driven")
# 
# # Other dropdowns
# fuel_dict = {"Select Fuel Type": None, "CNG": 0, "Diesel": 1, "LPG": 2, "Petrol": 3}
# fuel = st.selectbox("Fuel Type", list(fuel_dict.keys()))
# 
# seller_dict = {"Select Seller Type": None, "Dealer": 0, "Individual": 1, "Trustmark Dealer": 2}
# seller_type = st.selectbox("Seller Type", list(seller_dict.keys()))
# 
# trans_dict = {"Select Transmission": None, "Automatic": 0, "Manual": 1}
# transmission = st.selectbox("Transmission Type", list(trans_dict.keys()))
# 
# owner_dict = {
#     "Select Owner History": None,
#     "First Owner": 0,
#     "Second Owner": 1,
#     "Third Owner": 2,
#     "Fourth & Above": 3,
#     "Test Drive Car": 4
# }
# owner = st.selectbox("Owner History", list(owner_dict.keys()))
# 
# # Predict and show result
# if st.button("Predict Price"):
#     if (
#         year == "Select Year" or km_driven == "Select KM Driven"
#         or fuel_dict[fuel] is None or seller_dict[seller_type] is None
#         or trans_dict[transmission] is None or owner_dict[owner] is None
#     ):
#         st.error("âš ï¸ Please select all fields before predicting.")
#     else:
#         user_input = pd.DataFrame([[int(year), int(km_driven), fuel_dict[fuel],
#                                     seller_dict[seller_type], trans_dict[transmission], owner_dict[owner]]],
#                                   columns=['year', 'km_driven', 'fuel', 'seller_type', 'transmission', 'owner'])
#         price = model.predict(user_input)[0]
#         low = price * 0.9
#         high = price * 1.1
# 
#         # Show 3 price options
#         st.markdown("### ğŸ¯ Estimated Car Price Range")
#         col1, col2, col3 = st.columns(3)
#         col1.metric("ğŸ”» Minimum Price", f"â‚¹ {low:,.0f}")
#         col2.metric("ğŸ’° Estimated Price", f"â‚¹ {price:,.0f}")
#         col3.metric("ğŸ”º Maximum Price", f"â‚¹ {high:,.0f}")
# 
#         # Show feature importance
#         st.markdown("### ğŸ” Feature Importance of Each Input")
#         importance = model.feature_importances_
#         labels = ['Year', 'KM Driven', 'Fuel Type', 'Seller Type', 'Transmission', 'Owner History']
#         imp_df = pd.DataFrame({'Feature': labels, 'Importance': importance * 100})
#         imp_df = imp_df.sort_values(by='Importance')
# 
#         # Plot
#         fig, ax = plt.subplots(figsize=(8, 5))
#         sns.barplot(data=imp_df, x='Importance', y='Feature', palette='flare', ax=ax)
# 
#         # Add value labels manually using ax.text
#         for bar in ax.patches:
#             width = bar.get_width()
#             ax.text(width + 1, bar.get_y() + bar.get_height() / 2,
#                     f'{width:.1f}%', va='center', fontsize=10)
# 
#         # Final touches
#         ax.set_xlabel("Importance (%)", fontsize=12)
#         ax.set_ylabel("Feature", fontsize=12)
#         ax.set_title("Feature Importance in Price Prediction", fontsize=14)
#         ax.grid(True, axis='x', linestyle='--', alpha=0.5)
# 
#         st.pyplot(fig)
#

!ngrok config add-authtoken 30gP3R7Xyj2X4QY0xEs5D5MWocN_KgdE11cNbCPriMRrP55N

from pyngrok import ngrok

# Kill all active tunnels
ngrok.kill()
from pyngrok import ngrok
!streamlit run app.py &>/content/logs.txt &
import time; time.sleep(5)
public_url = ngrok.connect(addr='8501')
print(f"ğŸŒ App Link: {public_url}")